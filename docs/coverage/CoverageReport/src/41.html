<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Manue\Documents\Work\FAtiMA\Components\WellFormedNames\Implementation\Symbol.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
#if PORTABLE
using SerializationUtilities.Attributes;
#endif

namespace WellFormedNames
{
	public partial class Name
	{
		/// &lt;summary&gt;
		/// Instantiation of a Simple Well Formed Name composed by just one literal 
		/// 
		/// Well Formed Name with just one literal The alphabet that makes up the symbols
		/// expressions consists of: 
		/// • The set of letters, upper and lowercase.
		/// • The set of digits, 0,1,..,9 
		/// • The symbols “_”, “-”, &quot;*&quot;
		/// 
		/// Symbols expressions begin with a letter and are followed by any sequence of 
		/// these legal characters. Well formed names are composed by four types 
		/// of symbols:
		///		1. The Truth symbols &quot;True&quot; and &quot;False&quot;.
		///		2. Constant symbols, which are simple symbol expressions.
		///		3. Variables symbols, which are symbol expressions enclosed in square
		///		parentheses. Ex: [x] represents the variable x. 
		///		4. The Self symbol [SELF], a reserved special variable which
		///		refers to the agent.
		///		
		/// @author: Jo&#227;o Dias
		/// @author: Pedro Gon&#231;alves (C# version)
		/// &lt;/summary&gt;
		/// &lt;see cref=&quot;Name&quot;/&gt;
		[Serializable]
		private abstract class Symbol : Name
		{
			protected Symbol(bool isGrounded, bool isUniversal, bool isConstant, bool isVariable, bool isPrimitive)
				: base(isGrounded, isUniversal, isConstant, isVariable, isPrimitive,false)
			{
			}

			public sealed override int NumberOfTerms
			{
				get { return 1; }
			}

			public sealed override Name GetFirstTerm()
			{
				return this;
			}

			public sealed override IEnumerable&lt;Name&gt; GetTerms()
			{
				yield return this;
			}

			public sealed override Name GetNTerm(int index)
			{
				if(index!=0)
					throw new IndexOutOfRangeException();

				return this;
			}

			public sealed override IEnumerable&lt;Name&gt; GetLiterals()
			{
				yield return this;
			}

			public override Name ApplyToTerms(Func&lt;Name, Name&gt; transformFunction)
			{
				return transformFunction(this);
			}
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[38,7,38,79,1],[39,4,39,5,1],[40,4,40,5,1],[44,9,44,10,1],[44,11,44,20,1],[44,21,44,22,1],[48,4,48,5,1],[49,5,49,17,1],[50,4,50,5,1],[53,4,53,5,1],[54,5,54,23,1],[55,4,55,5,1],[58,4,58,5,0],[59,5,59,17,0],[60,6,60,43,0],[62,5,62,17,0],[63,4,63,5,0],[66,4,66,5,0],[67,5,67,23,0],[68,4,68,5,0],[71,4,71,5,1],[72,5,72,36,1],[73,4,73,5,1]]);
    </script>
  </body>
</html>